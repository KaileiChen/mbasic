%% \VignetteIndexEntry{CSSP: ChIP-Seq Statistical Power}
\documentclass[a4paper,10pt]{article}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}
\usepackage{amsmath,mathrsfs,graphicx}
%\usepackage[top=2cm,bottom=2cm,left=2cm,right=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{color}
%\usepackage{natbib}

%\usepackage{Sweave}
\RequirePackage{/afs/cs.wisc.edu/u/z/u/zuo/R/x86_64-redhat-linux-gnu-library/3.0/BiocStyle/sty/Bioconductor}


\title{MBASIC: Matrix Based Analysis for State-space Inference and Clustering}

\author{Chandler Zuo and S\"und\"uz Kele\c{s}\\
  Departments of Statistics and of  Biostatistics and Medical Informatics, University of Wisconsin-Madison}
\date{}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}
\maketitle

\tableofcontents

\section{Introduction}

This document provides an introduction to the power analysis of ChIP-seq data with the \software{MBASIC} package (\textbf{MBASIC} which stands for \textbf{M}atrix \textbf{B}ased \textbf{A}nalysis for \textbf{S}tate-space \textbf{I}nference and \textbf{C}lustering) \cite{zuo14}. \software{MBASIC} provides a Bayesian framework for clustering units based on their infered states over a set of experimental conditions.

\software{MBASIC} is especially useful for integrative analysis for ChIP-seq experiments. In this case, a set of prespecified loci is clustered based on their activities over celltypes and transcription factors. We build a pipeline in the \software{MBASIC} package and will focus on this pipeline in this vignette. We will introduce the general functionalities for the \textbf{MBASIC} model at the end of the vignette.

\section{MBASIC Pipeline for Sequencing Data}

\subsection{Overview}

Applying the \textbf{MBASIC} framework to analyzing ChIP-seq data sets includes three steps:

\begin{enumerate}
\item \textit{Matching each ChIP replicate data set with their input data set:} This step matches ChIP replicate files with their matching input files;
\item \textit{Calculating mapped counts and the covariate on the target loci:} This step calculates the mapped counts from each ChIP and input replicate files on each of the target locus;
\item \textit{Fitting MBASIC model:} This step fits the MBASIC model to identify the binding states for each locus and cluster the loci based on their binding states across different conditions.
\end{enumerate}

\software{MBASIC} integrates Step 2-3 in a single function \Rfunction{MBASIC.pipeline}. For Step 1 \software{MBASIC} provides a function \Rfunction{ChIPInputMatch} that assists matching the ChIP files with input files based on the naming convention of the ENCODE datasets. We have found that in practice, more often than not, some violations to the ENCODE file name conventions always occur, and manual adjustments to the results of our automated matching are inevitable. Therefore, we do not integrate this function in \Rfunction{MBASIC.pipeline}.

\subsection{Step 1: Match ChIP and Input Datasets}



To illustrate Step 1 we first generate a set of synthetic data. \software{MBASIC} package provides a function \Rfunction{generateSyntheticData} to assist our demo. This function generates synthetic BED data for ChIP and input samples, as well as mappability and GC scores in a directory specified by the 'dir' argument. It also generates a target set of loci for our analysis. By default, the number of loci is 100, each with size 20 bp. All data are generated across 5 chromosomes, each with size 10K bp. ChIP data are from 2 celltypes, and for each celltype there are K=5 TFs. Under each condition randomly 1-3 replicates for the ChIP data are generated. All ChIP data from the same celltype are matched to the same set of 3 input replicates.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(MBASIC)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{target} \hlkwb{<-} \hlkwd{generateSyntheticData}\hlstd{(}\hlkwc{dir} \hlstd{=} \hlstr{"syntheticData"}\hlstd{)}
\hlkwd{head}\hlstd{(target)}
\end{alltt}
\begin{verbatim}
## RangedData with 6 rows and 1 value column across 1 space
##      space       ranges |  chromosome
##   <factor>    <IRanges> | <character>
## 1        1 [4920, 4940] |        chr4
## 2        1 [3960, 3980] |        chr5
## 3        1 [4000, 4020] |        chr2
## 4        1 [8360, 8380] |        chr5
## 5        1 [6680, 6700] |        chr5
## 6        1 [5400, 5420] |        chr2
\end{verbatim}
\begin{alltt}
\hlkwd{system}\hlstd{(}\hlstr{"ls syntheticData/*/*"}\hlstd{,} \hlkwc{intern} \hlstd{=} \hlnum{TRUE}\hlstd{)[}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [1] "syntheticData/chip/wgEncodeLabExpCell1Fac1CtrlAlnRep1.bed"
## [2] "syntheticData/chip/wgEncodeLabExpCell1Fac2CtrlAlnRep1.bed"
## [3] "syntheticData/chip/wgEncodeLabExpCell1Fac2CtrlAlnRep2.bed"
## [4] "syntheticData/chip/wgEncodeLabExpCell1Fac2CtrlAlnRep3.bed"
## [5] "syntheticData/chip/wgEncodeLabExpCell1Fac3CtrlAlnRep1.bed"
\end{verbatim}
\end{kframe}
\end{knitrout}

We have developed the \Rfunction{ChIPInputMatch} function to help match the ChIP and input data files. In the following example, we use this function to read all files with suffices ``.bed" and ``.bam'' in directories specified by the argument ``dir", and matches the files assuming ENCODE naming convention. It looks up files up to the number of levels of subdirectories specified by ``depth". The output of this function contains multiple columns. The first column contains the file name for each ChIP replicate. The second column is the initial string for the matching input replicates, because for each ChIP replicate there are possibly multiple input replicates. The rest of the columns contains information for lab, experiment identifier, factor and control identifier. This information is parsed from the file names.

We acknowledge that the current function may not parse all data file names correctly. For practical data files, users are suggested to check its result, and manual corrections may be needed.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{tbl} \hlkwb{<-} \hlkwd{ChIPInputMatch}\hlstd{(}\hlkwc{dir} \hlstd{=} \hlkwd{paste}\hlstd{(}\hlstr{"syntheticData/"}\hlstd{,} \hlkwd{c}\hlstd{(}\hlstr{"chip"}\hlstd{,} \hlstr{"input"}\hlstd{),} \hlkwc{sep} \hlstd{=} \hlstr{""}\hlstd{),} \hlkwc{celltypes} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"Cell1"}\hlstd{,}
    \hlstr{"Cell2"}\hlstd{),} \hlkwc{suffices} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{".bam"}\hlstd{,} \hlstr{".bed"}\hlstd{),} \hlkwc{depth} \hlstd{=} \hlnum{5}\hlstd{)}
\hlkwd{head}\hlstd{(tbl)}
\end{alltt}
\begin{verbatim}
##                                                    chipfile
## 1 syntheticData/chip/wgEncodeLabExpCell1Fac1CtrlAlnRep1.bed
## 2 syntheticData/chip/wgEncodeLabExpCell1Fac2CtrlAlnRep1.bed
## 3 syntheticData/chip/wgEncodeLabExpCell1Fac2CtrlAlnRep2.bed
## 4 syntheticData/chip/wgEncodeLabExpCell1Fac2CtrlAlnRep3.bed
## 5 syntheticData/chip/wgEncodeLabExpCell1Fac3CtrlAlnRep1.bed
## 6 syntheticData/chip/wgEncodeLabExpCell1Fac3CtrlAlnRep2.bed
##                                          inputfile lab experiment  cell factor control
## 1 syntheticData/input/wgEncodeLabExpCell1InputCtrl Lab        Exp Cell1   Fac1    Ctrl
## 2 syntheticData/input/wgEncodeLabExpCell1InputCtrl Lab        Exp Cell1   Fac2    Ctrl
## 3 syntheticData/input/wgEncodeLabExpCell1InputCtrl Lab        Exp Cell1   Fac2    Ctrl
## 4 syntheticData/input/wgEncodeLabExpCell1InputCtrl Lab        Exp Cell1   Fac2    Ctrl
## 5 syntheticData/input/wgEncodeLabExpCell1InputCtrl Lab        Exp Cell1   Fac3    Ctrl
## 6 syntheticData/input/wgEncodeLabExpCell1InputCtrl Lab        Exp Cell1   Fac3    Ctrl
##   chipformat inputformat
## 1        BED         BED
## 2        BED         BED
## 3        BED         BED
## 4        BED         BED
## 5        BED         BED
## 6        BED         BED
\end{verbatim}
\end{kframe}
\end{knitrout}

We also need to specify the experimental condition for each data set by a vector 'conds'.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{conds} \hlkwb{<-} \hlkwd{paste}\hlstd{(tbl}\hlopt{$}\hlstd{cell, tbl}\hlopt{$}\hlstd{factor,} \hlkwc{sep} \hlstd{=} \hlstr{"."}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\subsection{Executing Step 2 and 3 Altogether}

Now we are in a position to continue the next steps in the pipeline. There are two ways to execute these steps: (1) use function \Rfunction{MBASIC.pipeline}, which wraps up all the consecutive steps; or (2) execute each step separately. The following code calls the function Rfunction{MBASIC.pipeline}:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## remove file 'data.Rda' since it will be generated try(file.remove('data.Rda'))}
\hlstd{fit} \hlkwb{<-} \hlkwd{MBASIC.pipeline}\hlstd{(}\hlkwc{chipfile} \hlstd{= tbl}\hlopt{$}\hlstd{chipfile,} \hlkwc{inputfile} \hlstd{= tbl}\hlopt{$}\hlstd{inputfile,} \hlkwc{input.suffix} \hlstd{=} \hlstr{".bed"}\hlstd{,}
    \hlkwc{target} \hlstd{= target,} \hlkwc{chipformat} \hlstd{= tbl}\hlopt{$}\hlstd{chipformat,} \hlkwc{inputformat} \hlstd{= tbl}\hlopt{$}\hlstd{inputformat,} \hlkwc{fragLen} \hlstd{=} \hlnum{150}\hlstd{,}
    \hlkwc{pairedEnd} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{unique} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{fac} \hlstd{= conds,} \hlkwc{J} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{S} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{family} \hlstd{=} \hlstr{"negbin"}\hlstd{,} \hlkwc{datafile} \hlstd{=} \hlstr{"data.Rda"}\hlstd{)}
\hlkwd{class}\hlstd{(fit)}
\end{alltt}
\end{kframe}
\end{knitrout}

We list the meanings of the arguments of \Rfunction{MBASIC.pipeline} in Table \ref{tbl:arguments}. The above example fits a clustering model with 3 clusters. It returns an object of class \Rclass{MBASICFit}. This class is described in more details in Section \ref{sec:mbasicfit}.

Alternatively, we can fit models with varying numbers of clusters simultaneously, and pick the one with the minimum BIC value:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{allfits} \hlkwb{<-} \hlkwd{MBASIC.pipeline}\hlstd{(}\hlkwc{chipfile} \hlstd{= tbl}\hlopt{$}\hlstd{chipfile,} \hlkwc{inputfile} \hlstd{= tbl}\hlopt{$}\hlstd{inputfile,} \hlkwc{input.suffix} \hlstd{=} \hlstr{".bed"}\hlstd{,}
    \hlkwc{target} \hlstd{= target,} \hlkwc{chipformat} \hlstd{= tbl}\hlopt{$}\hlstd{chipformat,} \hlkwc{inputformat} \hlstd{= tbl}\hlopt{$}\hlstd{inputformat,} \hlkwc{fragLen} \hlstd{=} \hlnum{150}\hlstd{,}
    \hlkwc{pairedEnd} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{unique} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{fac} \hlstd{= conds,} \hlkwc{J} \hlstd{=} \hlnum{3}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{S} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{family} \hlstd{=} \hlstr{"negbin"}\hlstd{,} \hlkwc{datafile} \hlstd{=} \hlstr{"data.Rda"}\hlstd{)}
\hlkwd{names}\hlstd{(allfits)}
\end{alltt}
\begin{verbatim}
## [1] "allFits" "BestFit" "Time"
\end{verbatim}
\begin{alltt}
\hlkwd{class}\hlstd{(allfits}\hlopt{$}\hlstd{BestFit)}
\end{alltt}
\begin{verbatim}
## [1] "MBASICFit"
## attr(,"package")
## [1] "MBASIC"
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{table}
  \centering
  \caption{Arguments for the \Rfunction{MBASIC.pipeline} function. For a comprehensive list of arguments and their details, users are recommended to read our manual.}\label{tbl:arguments}
  \begin{tabular}{p{2cm}p{10cm}}
    \hline
    \multicolumn{2}{c}{Data Sources}\\
    \hline
    chipfile & A string vector for the ChIP files.\\
    inputfile & A string vector for the matching input files. The length must be the same as ``chipfile".\\
    input.suffix & A string for the suffix of input files. If NULL, ``inputfile" will be treated as the full names of the input files. Otherwise, all inputfiles with the initial ``inputfile" and this suffix will be merged.\\
    chipformat (inputformat) & A string specifying the type of all ChIP (input) files, or a vector of string specifying the types of each ChIP (input) file.  Currently three file types are allowed: ``BAM", ``BED" or ``TAGALIGN'' (``TAGALIGN'' and ``BED'' files are treated as same).  Default: ``BAM".\\
    m.prefix (optional) & A string for the prefix of the mappability files.\\
    m.suffix (optional) & A string for the suffix of the mappability files. See our man files for more details.  Default: NULL.\\
    gc.prefix (optional) & A string for the prefix of the GC files.\\
    gc.suffix (optional) & A string for the suffix of the GC files.  See our man files for more details. Default: NULL.\\
    \hline
    \multicolumn{2}{c}{Genomic Information}\\
    \hline
    target & A RangedData object for the target intervals where the reads are mapped.\\
    fragLen & Either a single value or a 2-column matrix of the fragment lengths for the chip and input files.  Default: 150.\\
    pairedEnd & Either a boolean value or a 2-column boolean matrix for  whether each file is a paired-end data set. Currently this function only allows ``BAM" files for paired-end data. Default: FALSE.\\
    unique & A boolean value for whether only reads with distinct genomic coordinates or strands are mapped.  Default: TRUE.\\
    \hline
    \multicolumn{2}{c}{Model Parameters}\\
    \hline
    S & The number of states.\\
    fac & A vector of length N for the experimental condition of each ChIP replicate.\\
    struct & A matrix indicating the levels of the signal matrix. \\
    J & A single number or a numeric vector of the numbers of clusters to be included in the model.\\
    family & The distribution of family to be used.  \software{MBASIC} currently support five distribution types: 'lognormal', 'negbin', 'binom', 'scaled-t', 'gamma-binom'. See our man files for more information.\\
    \hline
    \multicolumn{2}{c}{Tuning Parameters}\\
    \hline
    maxitr & The maximum number of iterations in the E-M algorithm. Default: 100.\\
    tol & Tolerance for the relative increment in the log-likelihood function to check the E-M algorithm's convergence. Default: 1e-10.\\
    tol.par & Tolerance for the maximum relative change in parameters to check the algorithm's convergence. Default: 1e-5.\\
    datafile & The location to save the count matrices, or load pre-computed count matrices.\\
    \hline
  \end{tabular}
\end{table}

Before we move on to describe the step-wise execution, we highlight the usage of argument 'datafile'. When we fit 'MBASIC.fit', we process ChIP and input data and save the processed data in 'datafile'. When we compute 'MBASIC.fit', since 'datafile' already exists on our disk, \Rfunction{MBASIC.allfit} automatically loads our processed data. This can save substantially amount of time if the size of our data is large.

\subsection{Step 2: Generate the Data Matrices}

We can execute Step 2 and 3 separately. In Step 2, we use the function \Rfunction{generateReadMatrices} to calculate the ChIP count at each locus for each ChIP replicate. We also calculate the count at each locus for each matching input.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## Step 2: Generate mapped count matrices}
\hlstd{dat} \hlkwb{<-} \hlkwd{generateReadMatrices}\hlstd{(}\hlkwc{chipfile} \hlstd{= tbl}\hlopt{$}\hlstd{chipfile,} \hlkwc{inputfile} \hlstd{= tbl}\hlopt{$}\hlstd{inputfile,} \hlkwc{input.suffix} \hlstd{=} \hlstr{".bed"}\hlstd{,}
    \hlkwc{target} \hlstd{= target,} \hlkwc{chipformat} \hlstd{= tbl}\hlopt{$}\hlstd{chipformat,} \hlkwc{inputformat} \hlstd{= tbl}\hlopt{$}\hlstd{inputformat,} \hlkwc{fragLen} \hlstd{=} \hlnum{150}\hlstd{,}
    \hlkwc{pairedEnd} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{unique} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{conds} \hlkwb{<-} \hlkwd{paste}\hlstd{(tbl}\hlopt{$}\hlstd{cell, tbl}\hlopt{$}\hlstd{factor,} \hlkwc{sep} \hlstd{=} \hlstr{"."}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can directly use the matching input counts as the covariate data in our model. Advanced users of our package may want to normalize the input counts according to the mappability and GC scores and use the normalized counts as the covariate. In that case, we need call functions \Rfunction{averageMGC} and \Rfunction{bkng\_mean}.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## Step 2': calculate the mappability and GC-content scores for each locus}
\hlstd{target} \hlkwb{<-} \hlkwd{averageMGC}\hlstd{(}\hlkwc{target} \hlstd{= target,} \hlkwc{m.prefix} \hlstd{=} \hlstr{"syntheticData/mgc/"}\hlstd{,} \hlkwc{m.suffix} \hlstd{=} \hlstr{"_M.txt"}\hlstd{,}
    \hlkwc{gc.prefix} \hlstd{=} \hlstr{"syntheticData/mgc/"}\hlstd{,} \hlkwc{gc.suffix} \hlstd{=} \hlstr{"_GC.txt"}\hlstd{)}
\hlcom{## Step 2': compute the normalized input counts}
\hlstd{dat}\hlopt{$}\hlstd{input1} \hlkwb{<-} \hlkwd{bkng_mean}\hlstd{(}\hlkwc{inputdat} \hlstd{= dat}\hlopt{$}\hlstd{input,} \hlkwc{target} \hlstd{= target,} \hlkwc{family} \hlstd{=} \hlstr{"negbin"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Notice that such a normalization step is automatically executed if users specify the 'm.prefix', 'm.suffix', 'gc.prefix' and 'gc.suffix' arguments in \Rfunction{MASIC.pipeline}.



\subsection{Step 3: Build the MBASIC Model}



We can build an MBASIC model using function \Rfunction{MBASIC}:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## Step 3: Fit an MBASIC model}
\hlstd{fit} \hlkwb{<-} \hlkwd{MBASIC}\hlstd{(}\hlkwc{Y} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{chip),} \hlkwc{Gamma} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{input),} \hlkwc{S} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{fac} \hlstd{= conds,} \hlkwc{J} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{maxitr} \hlstd{=} \hlnum{10}\hlstd{,}
    \hlkwc{family} \hlstd{=} \hlstr{"negbin"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

We can also simultaneously fit models with different numbers of clusters:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## Step 3: Fit an MBASIC model}
\hlstd{allfits} \hlkwb{<-} \hlkwd{MBASIC.full}\hlstd{(}\hlkwc{Y} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{chip),} \hlkwc{Gamma} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{input),} \hlkwc{S} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{fac} \hlstd{= conds,} \hlkwc{J} \hlstd{=} \hlnum{3}\hlopt{:}\hlnum{10}\hlstd{,}
    \hlkwc{maxitr} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{family} \hlstd{=} \hlstr{"negbin"}\hlstd{,} \hlkwc{ncores} \hlstd{=} \hlnum{10}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Interpreting the Results}\label{sec:mbasicfit}

The outputs of both \Rfunction{MBASIC} and \Rfunction{MBASIC.pipeline} functions are of S-4 class \Rclass{MBASICFit}.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{showClass}\hlstd{(}\hlstr{"MBASICFit"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Slot 'Theta' records the probabilities for each locus to have each state under each condition. For a model with K experiment conditions, S states and I units, slot 'Theta' is a matrix of dimension KS by I, and the (K(s-1)+k, i)-th entry is the probability for the i-th locus to have state s under condition k. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{dim}\hlstd{(fit}\hlopt{@}\hlkwc{Theta}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1]  20 100
\end{verbatim}
\begin{alltt}
\hlkwd{rownames}\hlstd{(fit}\hlopt{@}\hlkwc{Theta}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] "Cell1.Fac1" "Cell1.Fac2" "Cell1.Fac3" "Cell1.Fac4" "Cell1.Fac5" "Cell2.Fac1"
##  [7] "Cell2.Fac2" "Cell2.Fac3" "Cell2.Fac4" "Cell2.Fac5" "Cell1.Fac1" "Cell1.Fac2"
## [13] "Cell1.Fac3" "Cell1.Fac4" "Cell1.Fac5" "Cell2.Fac1" "Cell2.Fac2" "Cell2.Fac3"
## [19] "Cell2.Fac4" "Cell2.Fac5"
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(fit}\hlopt{@}\hlkwc{Theta}\hlstd{[}\hlnum{1}\hlstd{, ])}
\end{alltt}
\begin{verbatim}
## [1] 0.985857771 0.006634503 0.188286952 0.212285459 0.742954763 0.674824843
\end{verbatim}
\end{kframe}
\end{knitrout}

In our example, suppose state 1 corresponds to the un-enriched state, and state 2 the enriched state. We can use the function \Rfunction{plot} to draw a heatmap to visualize the enrichment states across all data.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(fit,} \hlkwc{slot} \hlstd{=} \hlstr{"Theta"}\hlstd{,} \hlkwc{xlab} \hlstd{=} \hlstr{"Locus"}\hlstd{,} \hlkwc{state} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{cexRow} \hlstd{=} \hlnum{0.6}\hlstd{,} \hlkwc{cexCol} \hlstd{=} \hlnum{0.4}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/unnamed-chunk-18-1} 

}



\end{knitrout}

Slot 'clustProb' is a matrix for the posterior probablity of each locus to belong to each cluster. The first column contains the probability for each locus to be a singleton (i.e. not belong to any clusters). The (j+1)-th column contains the probabilities for each locus to be in cluster j.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{dim}\hlstd{(fit}\hlopt{@}\hlkwc{clustProb}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 100   4
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlkwd{head}\hlstd{(fit}\hlopt{@}\hlkwc{clustProb}\hlstd{),} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      b.prob                  
## [1,]  0.878 0.000 0.122 0.000
## [2,]  0.995 0.000 0.005 0.000
## [3,]  0.971 0.002 0.017 0.010
## [4,]  0.335 0.014 0.002 0.649
## [5,]  0.286 0.004 0.710 0.000
## [6,]  0.046 0.952 0.002 0.000
\end{verbatim}
\begin{alltt}
\hlstd{clusterLabels} \hlkwb{<-} \hlkwd{apply}\hlstd{(fit}\hlopt{@}\hlkwc{clustProb}\hlstd{,} \hlnum{1}\hlstd{, which.max)} \hlopt{-} \hlnum{1}
\hlkwd{table}\hlstd{(clusterLabels)}
\end{alltt}
\begin{verbatim}
## clusterLabels
##  0  1  2  3 
## 52 13 20 15
\end{verbatim}
\end{kframe}
\end{knitrout}

Slot 'W' is a matrix for the state-space profiles for all clusters. For a model with K conditions, S states and J clusters, this matrix has dimension KS by J, where the (k+K(s-1),j)-th entry contains the probability that a unit in cluster j has state s under condition k. For our example, the enriched probability for all clusters is in rows 11-20.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{rownames}\hlstd{(fit}\hlopt{@}\hlkwc{W}\hlstd{)}
\end{alltt}
\begin{verbatim}
##  [1] "Cell1.Fac1" "Cell1.Fac2" "Cell1.Fac3" "Cell1.Fac4" "Cell1.Fac5" "Cell2.Fac1"
##  [7] "Cell2.Fac2" "Cell2.Fac3" "Cell2.Fac4" "Cell2.Fac5" "Cell1.Fac1" "Cell1.Fac2"
## [13] "Cell1.Fac3" "Cell1.Fac4" "Cell1.Fac5" "Cell2.Fac1" "Cell2.Fac2" "Cell2.Fac3"
## [19] "Cell2.Fac4" "Cell2.Fac5"
\end{verbatim}
\begin{alltt}
\hlkwd{dim}\hlstd{(fit}\hlopt{@}\hlkwc{W}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 20  3
\end{verbatim}
\begin{alltt}
\hlkwd{round}\hlstd{(}\hlkwd{head}\hlstd{(fit}\hlopt{@}\hlkwc{W}\hlstd{[}\hlkwd{seq}\hlstd{(}\hlnum{10}\hlstd{)} \hlopt{+} \hlnum{10}\hlstd{, ]),} \hlnum{3}\hlstd{)}
\end{alltt}
\begin{verbatim}
##             [,1]  [,2]  [,3]
## Cell1.Fac1 0.389 0.004 0.999
## Cell1.Fac2 0.905 0.433 0.787
## Cell1.Fac3 0.005 0.996 0.000
## Cell1.Fac4 1.000 1.000 0.001
## Cell1.Fac5 0.531 0.949 0.032
## Cell2.Fac1 0.033 0.073 0.000
\end{verbatim}
\end{kframe}
\end{knitrout}

We can also use the \Rfunction{plot} function to visualize the probability for each cluster to have a particular state under all conditions.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(fit,} \hlkwc{slot} \hlstd{=} \hlstr{"W"}\hlstd{,} \hlkwc{state} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{cexRow} \hlstd{=} \hlnum{0.6}\hlstd{,} \hlkwc{cexCol} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{srtCol} \hlstd{=} \hlnum{0}\hlstd{,} \hlkwc{adjCol} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,} \hlnum{1}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/unnamed-chunk-21-1} 

}



\end{knitrout}

Slot 'Mu' and 'Sigma' are matrices for the distribution parameters for each replicate and each component (usually, one component is one state, see Section \ref{sec:component}).

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{dim}\hlstd{(fit}\hlopt{@}\hlkwc{Mu}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 18  2
\end{verbatim}
\begin{alltt}
\hlkwd{dim}\hlstd{(fit}\hlopt{@}\hlkwc{Sigma}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] 18  2
\end{verbatim}
\end{kframe}
\end{knitrout}

Function \Rfunction{plot} enables visualizing the range of the fitted parameter values across different replicates for the same condition. Notice that for these slots the function is implemented using \Rpackage{ggplot2}, so additional arguments can be passed by '+':

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(fit,} \hlkwc{slot} \hlstd{=} \hlstr{"Mu"}\hlstd{,} \hlkwc{state} \hlstd{=} \hlnum{2}\hlstd{)} \hlopt{+} \hlkwd{theme}\hlstd{(}\hlkwc{axis.text.x} \hlstd{=} \hlkwd{element_text}\hlstd{(}\hlkwc{angle} \hlstd{=} \hlnum{90}\hlstd{,} \hlkwc{hjust} \hlstd{=} \hlnum{1}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\maxwidth]{figure/unnamed-chunk-23-1} 

}



\end{knitrout}

\section{Advanced Functions}

\subsection{Model Initialization}

Function \Rfunction{MBASIC} accepts initial values for a number of parameters. This is especially useful when an initial run of \Rfunction{MBASIC} reaches the maximum number of iterations, but the algorithm is not converged. In this case, we can rerun the \Rfunction{MBASIC} using the previously fitted model parameters to initialize the model.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fit.update} \hlkwb{<-} \hlkwd{MBASIC}\hlstd{(}\hlkwc{Y} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{chip),} \hlkwc{Gamma} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{input),} \hlkwc{S} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{fac} \hlstd{= conds,} \hlkwc{J} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{maxitr} \hlstd{=} \hlnum{10}\hlstd{,}
    \hlkwc{family} \hlstd{=} \hlstr{"negbin"}\hlstd{,} \hlkwc{Mu.init} \hlstd{= fit}\hlopt{@}\hlkwc{Mu}\hlstd{,} \hlkwc{Sigma.init} \hlstd{= fit}\hlopt{@}\hlkwc{Sigma}\hlstd{,} \hlkwc{V.init} \hlstd{= fit}\hlopt{@}\hlkwc{V}\hlstd{,} \hlkwc{ProbMat.init} \hlstd{= fit}\hlopt{@}\hlkwc{Theta}\hlstd{,}
    \hlkwc{W.init} \hlstd{= fit}\hlopt{@}\hlkwc{W}\hlstd{,} \hlkwc{Z.init} \hlstd{= fit}\hlopt{@}\hlkwc{Z}\hlstd{,} \hlkwc{b.init} \hlstd{= fit}\hlopt{@}\hlkwc{b}\hlstd{,} \hlkwc{P.init} \hlstd{= fit}\hlopt{@}\hlkwc{P}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\subsection{Multiple Components in a State}\label{sec:component}

MBASIC model assumes that the distribution of each data is a mixture of several components, and the components are mapped to different states. In the simpliest cases, each component corresponds to a distinct state. In some cases, we might want to include multiple components in one state. For example, for ChIP-seq data, we may want to include two components for the enriched state to capture both the weakly enriched and strongly enriched loci. This can be done by specifying the 'statemap' value. In the following example, we assume there are three components for data set, the first component corresponds to the un-enriched state, the second and the third components both belong to the enriched states.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{fit.mix} \hlkwb{<-} \hlkwd{MBASIC}\hlstd{(}\hlkwc{Y} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{chip),} \hlkwc{Gamma} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{input),} \hlkwc{S} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{fac} \hlstd{= conds,} \hlkwc{J} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{maxitr} \hlstd{=} \hlnum{10}\hlstd{,}
    \hlkwc{family} \hlstd{=} \hlstr{"negbin"}\hlstd{,} \hlkwc{statemap} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{2}\hlstd{,} \hlnum{2}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\subsection{Simulation}

The \software{MBASIC} package also provides functions to simulate and fit general MBASIC models.

Function \Rfunction{MBASIC.sim} simulates data with 'I' units and 'J' clusters. The 'S' argument specifies the number of different states, and 'zeta' is the proportion of singleton. 'fac' specifies the condition for each experiment. The 'xi' argument relates to the magnitude of the simulated data. For detailed description users are recommended to read our manual.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## Simulate data across I=1000 units with J=3 clusters There are S=3 states}
\hlstd{dat.sim} \hlkwb{<-} \hlkwd{MBASIC.sim}\hlstd{(}\hlkwc{xi} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{family} \hlstd{=} \hlstr{"lognormal"}\hlstd{,} \hlkwc{I} \hlstd{=} \hlnum{1000}\hlstd{,} \hlkwc{fac} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlkwc{each} \hlstd{=} \hlnum{2}\hlstd{),} \hlkwc{J} \hlstd{=} \hlnum{3}\hlstd{,}
    \hlkwc{S} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{zeta} \hlstd{=} \hlnum{0.1}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\Rfunction{MBASIC.sim} returns a list object. The 'Y' field contains the simulated data matrix at each unit (column) for each experiment (row). The 'Theta' field is the matrix for the states for each unit (column) and each experimental condition (column). The 'W' field is a matrix with dimensions KS $\times$ J, where the (S(k-1)+s,j)-th entry is the probability that units in the j-th cluster have state s under the k-th condition.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{names}\hlstd{(dat.sim)}
\end{alltt}
\begin{verbatim}
##  [1] "Theta"      "Y"          "X"          "fac"        "W"          "Z"         
##  [7] "V"          "delta"      "zeta"       "prior.mean" "prior.sd"   "stdev"     
## [13] "Mu"         "bkng"       "snr"        "non.id"
\end{verbatim}
\begin{alltt}
\hlkwd{dim}\hlstd{(dat.sim}\hlopt{$}\hlstd{Y)}
\end{alltt}
\begin{verbatim}
## [1]   20 1000
\end{verbatim}
\begin{alltt}
\hlkwd{dim}\hlstd{(dat.sim}\hlopt{$}\hlstd{W)}
\end{alltt}
\begin{verbatim}
## [1] 30  3
\end{verbatim}
\begin{alltt}
\hlkwd{dim}\hlstd{(dat.sim}\hlopt{$}\hlstd{Theta)}
\end{alltt}
\begin{verbatim}
## [1]   10 1000
\end{verbatim}
\end{kframe}
\end{knitrout}

We can apply \Rfunction{MBASIC} to this simulated data. If we pass the simulated data to the function through the 'para' argument, we can get the following slots on the estimation error:

\begin{itemize}
\item \textit{ARI}: Adjusted Rand Index;
\item \textit{W.err}: The mean squared error in matrix W;
\item \textit{Theta.err}: The mean squared error in state estimation;
\item \textit{MisClassRate}: The mis-classification rate.
\end{itemize}
 
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{dat.sim.fit} \hlkwb{<-} \hlkwd{MBASIC}\hlstd{(}\hlkwc{Y} \hlstd{= dat.sim}\hlopt{$}\hlstd{Y,} \hlkwc{S} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{fac} \hlstd{= dat.sim}\hlopt{$}\hlstd{fac,} \hlkwc{J} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{maxitr} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{para} \hlstd{= dat.sim,}
    \hlkwc{family} \hlstd{=} \hlstr{"lognormal"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{dat.sim.fit}\hlopt{@}\hlkwc{ARI}
\end{alltt}
\begin{verbatim}
## [1] 0.9919925
\end{verbatim}
\begin{alltt}
\hlstd{dat.sim.fit}\hlopt{@}\hlkwc{W.err}
\end{alltt}
\begin{verbatim}
## [1] 0.0870422
\end{verbatim}
\begin{alltt}
\hlstd{dat.sim.fit}\hlopt{@}\hlkwc{Theta.err}
\end{alltt}
\begin{verbatim}
## [1] 0.1954791
\end{verbatim}
\begin{alltt}
\hlstd{dat.sim.fit}\hlopt{@}\hlkwc{MisClassRate}
\end{alltt}
\begin{verbatim}
## [1] 0.01232213
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection{Degenerate MBASIC Models}

In a degenerate MBASIC model, the states for each unit under each condition are directly observed. \Rfunction{MBASIC.sim.state} and \Rfunction{MBASIC.state} functions allows users to simulate and fit such models. The usage of these functions are similar to functions \Rfunction{MBASIC.sim} and \Rfunction{MBASIC}.

\Rfunction{MBASIC.sim.state} simulates data from a degenerate MBASIC model. Different from \Rfunction{MBASIC.sim}, \Rfunction{MBASIC.sim.state} does not need arguments 'fac' and 'family', but it needs the 'K' argument, specifying the number of experimental conditions.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{state.sim} \hlkwb{<-} \hlkwd{MBASIC.sim.state}\hlstd{(}\hlkwc{I} \hlstd{=} \hlnum{1000}\hlstd{,} \hlkwc{K} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{J} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{S} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{zeta} \hlstd{=} \hlnum{0.1}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\Rfunction{MBASIC.state} fits a degenerate MBASIC model. Different to function \Rfunction{MBASIC}, it does not need arguments 'Y' and 'family'. Instead, it needs the argument 'Theta' to pass the observed states.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{state.sim.fit} \hlkwb{<-} \hlkwd{MBASIC.state}\hlstd{(}\hlkwc{Theta} \hlstd{= state.sim}\hlopt{$}\hlstd{Theta,} \hlkwc{J} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{zeta} \hlstd{=} \hlnum{0.1}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\section{Session Information}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## R version 3.1.1 (2014-07-10)
## Platform: x86_64-redhat-linux-gnu (64-bit)
## 
## locale:
##  [1] LC_CTYPE=zh_TW.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8       
##  [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C              
## [10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] MBASIC_0.99.0        Rcpp_0.11.4          msm_1.5              mclust_4.4          
##  [5] MASS_7.3-33          gtools_3.4.1         gplots_2.16.0        ggplot2_1.0.0       
##  [9] GenomicRanges_1.14.4 XVector_0.2.0        IRanges_1.20.7       BiocGenerics_0.8.0  
## [13] doMC_1.3.3           iterators_1.0.7      foreach_1.4.2        cluster_1.15.2      
## 
## loaded via a namespace (and not attached):
##  [1] BiocStyle_1.0.0    bitops_1.0-6       caTools_1.17.1     codetools_0.2-8   
##  [5] colorspace_1.2-4   compiler_3.1.1     digest_0.6.8       evaluate_0.5.5    
##  [9] expm_0.99-1.1      formatR_1.0        gdata_2.13.3       grid_3.1.1        
## [13] gtable_0.1.2       highr_0.4          KernSmooth_2.23-12 knitr_1.9         
## [17] labeling_0.3       lattice_0.20-29    Matrix_1.1-5       munsell_0.4.2     
## [21] mvtnorm_1.0-2      plyr_1.8.1         proto_0.3-10       reshape2_1.4.1    
## [25] scales_0.2.4       splines_3.1.1      stats4_3.1.1       stringr_0.6.2     
## [29] survival_2.37-7    tools_3.1.1
\end{verbatim}
\end{kframe}
\end{knitrout}



\bibliographystyle{plain}

\bibliography{mbasic}

\end{document}


initial values for  that is accessible by the \Rfunction{MBASIC.binary} function but not \Rfunction{MBASIC.pipeline} is 'init.mod'. This argument allows the user to pass a ``MBASICFit" object, whose values are used to initialize the parameters in this function. It can be useful in two conditions:

\begin{enumerate}
\item The model fitted by a previous call of function ``MBASIC" has not yet converged, and the user wishes to increase the number of iterations;
\item The user wants to fit a MBASIC model with a larger number of clusters (``J")  from a previously fitted model;
\item The user wants to fit a MBASIC model with a different structural constraints (``struct") from a previously fitted model.
\end{enumerate}

In both cases, ``MBASIC.binary" uses the results from ``init.mod" before starting its iterations. This is significantly time saving than restarting the model fitting from scratch. However, this argument is dangerous if the user passes along a fitted model using different data sources or model structures. To avoid that, the user need to check that the arguments used to get ``init.mod" and in the current ``MBASIC.binary" must be consistent following rules below (which currently cannot be checked by our codes):

\begin{enumerate}
\item ``Y", ``Mu0", ``fac", ``family", ``nsig" must be the same;
\item ``J" for the ``MBASIC.binary" function must be larger than or equal to the value used in ``init.mod".
\end{enumerate}
   
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{## Fit a MBASIC model with 4 clusters}
\hlkwd{MBASIC.binary}\hlstd{(}\hlkwc{Y} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{chip),} \hlkwc{Mu0} \hlstd{=} \hlkwd{t}\hlstd{(Mu0),} \hlkwc{fac} \hlstd{= conds,} \hlkwc{J} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{zeta} \hlstd{=} \hlnum{0.2}\hlstd{,} \hlkwc{maxitr} \hlstd{=} \hlnum{100}\hlstd{,}
    \hlkwc{burnin} \hlstd{=} \hlnum{20}\hlstd{,} \hlkwc{init.mod} \hlstd{= fit,} \hlkwc{struct} \hlstd{=} \hlkwa{NULL}\hlstd{,} \hlkwc{family} \hlstd{=} \hlstr{"negbin"}\hlstd{,} \hlkwc{tol} \hlstd{=} \hlnum{1e-04}\hlstd{,} \hlkwc{nsig} \hlstd{=} \hlnum{2}\hlstd{)}

\hlcom{## Fit a MBASIC model with more iterations}
\hlkwd{MBASIC.binary}\hlstd{(}\hlkwc{Y} \hlstd{=} \hlkwd{t}\hlstd{(dat}\hlopt{$}\hlstd{chip),} \hlkwc{Mu0} \hlstd{=} \hlkwd{t}\hlstd{(Mu0),} \hlkwc{fac} \hlstd{= conds,} \hlkwc{J} \hlstd{=} \hlnum{3}\hlstd{,} \hlkwc{zeta} \hlstd{=} \hlnum{0.2}\hlstd{,} \hlkwc{maxitr} \hlstd{=} \hlnum{200}\hlstd{,}
    \hlkwc{burnin} \hlstd{=} \hlnum{20}\hlstd{,} \hlkwc{init.mod} \hlstd{= fit,} \hlkwc{struct} \hlstd{=} \hlkwa{NULL}\hlstd{,} \hlkwc{family} \hlstd{=} \hlstr{"negbin"}\hlstd{,} \hlkwc{tol} \hlstd{=} \hlnum{1e-04}\hlstd{,} \hlkwc{nsig} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}
